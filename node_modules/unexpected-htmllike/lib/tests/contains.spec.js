'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _unexpected = require('unexpected');

var _unexpected2 = _interopRequireDefault(_unexpected);

var _contains = require('../contains');

var _contains2 = _interopRequireDefault(_contains);

var _diff = require('../diff');

var _diff2 = _interopRequireDefault(_diff);

var expect = _unexpected2['default'].clone();

var TestAdapter = {
    getName: function getName(comp) {
        return comp.name;
    },

    getAttributes: function getAttributes(comp) {
        return comp.attribs;
    },

    getChildren: function getChildren(comp) {
        return comp.children && [].concat([], comp.children) || [];
    }
};

function getContains(actual, expected, options) {
    return (0, _contains2['default'])(TestAdapter, TestAdapter, actual, expected, expect, options);
}

expect.addType({

    name: 'TestHtmlElement',
    base: 'object',
    identify: function identify(value) {
        return value && typeof value === 'object' && typeof value.name === 'string' && typeof value.attribs === 'object';
    }
});

expect.addAssertion('<TestHtmlElement> when checked to contain <TestHtmlElement> <assertion>', function (expect, subject, value) {

    return (0, _contains2['default'])(TestAdapter, TestAdapter, subject, value, expect, {}).then(function (result) {
        expect.shift(result);
    });
});

expect.addAssertion('<TestHtmlElement> when checked with options to contain <object> <TestHtmlElement> <assertion>', function (expect, subject, options, value) {

    return (0, _contains2['default'])(TestAdapter, TestAdapter, subject, value, expect, options).then(function (result) {
        expect.shift(result);
    });
});

describe('contains', function () {

    it('finds an exact match', function () {
        return expect({ name: 'span', attribs: { className: 'foo' }, children: ['some content'] }, 'when checked to contain', { name: 'span', attribs: { className: 'foo' }, children: ['some content'] }, 'to satisfy', { found: true });
    });

    it('reports the inspection of the found item', function () {
        return expect({ name: 'span', attribs: { className: 'foo' }, children: ['some content'] }, 'when checked to contain', { name: 'span', attribs: { className: 'foo' }, children: ['some content'] }, 'to satisfy', {
            found: true,
            bestMatch: {
                diff: {
                    type: 'ELEMENT',
                    name: 'span',
                    attributes: [{ name: 'className', value: 'foo' }]
                }
            }
        });
    });

    it('reports not found when no exact match exists', function () {
        return expect({ name: 'span', attribs: { className: 'foo' }, children: ['some content'] }, 'when checked to contain', { name: 'span', attribs: { className: 'foo' }, children: ['some other content'] }, 'to satisfy', { found: false });
    });

    it('finds an element nested one deep', function () {
        return expect({ name: 'div', attribs: {}, children: [{ name: 'span', attribs: { className: 'foo' }, children: ['some content'] }]
        }, 'when checked to contain', { name: 'span', attribs: { className: 'foo' }, children: ['some content'] }, 'to satisfy', { found: true });
    });

    it('finds a deep nested element', function () {
        return expect({ name: 'div', attribs: {}, children: [{ name: 'span', attribs: { className: 'foo' }, children: ['blah'] }, { name: 'span', attribs: { className: 'foo' }, children: [{ name: 'span', attribs: { className: 'foo' }, children: ['some content'] }] }, { name: 'span', attribs: { className: 'foo' }, children: ['blubs'] }]
        }, 'when checked to contain', { name: 'span', attribs: { className: 'foo' }, children: ['some content'] }, 'to satisfy', { found: true, bestMatch: {
                diff: {
                    type: 'ELEMENT',
                    name: 'span',
                    attributes: [{ name: 'className', value: 'foo' }]
                }
            } });
    });

    it('finds a best match when the content is different', function () {
        return expect({ name: 'div', attribs: {}, children: [{ name: 'span', attribs: { className: 'foo' }, children: ['some different content'] }]
        }, 'when checked to contain', { name: 'span', attribs: { className: 'foo' }, children: ['some content'] }, 'to satisfy', { found: false, bestMatchItem: {
                name: 'span', attribs: { className: 'foo' }, children: ['some different content']
            } });
    });

    it('finds a best match in an array of children with an extra attribute', function () {
        return expect({ name: 'div', attribs: {}, children: [{ name: 'span', attribs: { className: 'foo' }, children: ['some content'] }, { name: 'span', attribs: { className: 'bar' }, children: ['some content'] }, { name: 'span', attribs: { className: 'candidate', id: 'abc' }, children: ['some content'] }]
        }, 'when checked to contain', { name: 'span', attribs: { className: 'candidate' }, children: ['some content'] }, 'to satisfy', { found: false, bestMatchItem: {
                name: 'span', attribs: { className: 'candidate', id: 'abc' }, children: ['some content']
            } });
    });

    it('returns a diff when the content is different', function () {
        return expect({ name: 'div', attribs: {}, children: [{ name: 'span', attribs: { className: 'foo' }, children: ['some different content'] }]
        }, 'when checked to contain', { name: 'span', attribs: { className: 'foo' }, children: ['some content'] }, 'to satisfy', {
            found: false,
            bestMatch: {
                diff: {
                    type: 'ELEMENT',
                    name: 'span',
                    attributes: [{ name: 'className', value: 'foo' }],
                    children: [{
                        type: 'CONTENT',
                        value: 'some different content',
                        diff: {
                            type: 'changed',
                            expectedValue: 'some content'
                        }
                    }]
                },
                weight: _diff2['default'].DefaultWeights.STRING_CONTENT_MISMATCH
            }
        });
    });

    it('doesn\'t include wrappers in the bestMatchItem around the item that is found', function () {
        var searchItem = {
            name: 'div', attribs: {}, children: [{
                name: 'wrapper', attribs: { className: 'the-wrapper' },
                children: [{ name: 'span', attribs: { className: 'foo' }, children: ['some different content'] }]

            }]
        };

        return expect({
            name: 'body', attribs: {}, children: [searchItem]
        }, 'when checked with options to contain', { diffWrappers: false }, {
            name: 'div', attribs: {}, children: [{ name: 'span', attribs: { className: 'foo' }, children: ['some content'] }]
        }, 'to satisfy', {
            found: false,
            bestMatchItem: searchItem
        });
    });

    it('doesn\'t include wrappers in the bestMatch around the item that is found', function () {
        return expect({
            name: 'body', attribs: {}, children: [{
                name: 'div', attribs: {}, children: [{
                    name: 'wrapper', attribs: { className: 'the-wrapper' },
                    children: [{ name: 'span', attribs: { className: 'foo' }, children: ['some different content'] }]

                }]
            }]
        }, 'when checked with options to contain', { diffWrappers: false }, {
            name: 'div', attribs: {}, children: [{ name: 'span', attribs: { className: 'foo' }, children: ['some content'] }]
        }, 'to satisfy', {
            found: false,
            bestMatch: {
                diff: {
                    type: 'ELEMENT',
                    name: 'div', // Top level in the diff is the div, not the body
                    children: [{
                        type: 'WRAPPERELEMENT',
                        name: 'wrapper'
                    }]
                }
            }
        });
    });

    it('doesn\'t include wrappers in the bestMatch around an item that is found to match', function () {
        return expect({
            name: 'body', attribs: {}, children: [{
                name: 'div', attribs: {}, children: [{
                    name: 'wrapper', attribs: { className: 'the-wrapper' },
                    children: [{ name: 'span', attribs: { className: 'foo' }, children: ['some content'] }]

                }]
            }]
        }, 'when checked with options to contain', { diffWrappers: false }, {
            name: 'div', attribs: {}, children: [{ name: 'span', attribs: { className: 'foo' }, children: ['some content'] }]
        }, 'to satisfy', {
            found: true,
            bestMatch: {
                diff: {
                    type: 'ELEMENT',
                    name: 'div', // Top level in the diff is the div, not the body
                    children: [{
                        type: 'WRAPPERELEMENT',
                        name: 'wrapper'
                    }]
                }
            }
        });
    });
});
//# sourceMappingURL=contains.spec.js.map
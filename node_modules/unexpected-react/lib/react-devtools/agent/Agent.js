/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @flow
 */
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _require = require('events');

var EventEmitter = _require.EventEmitter;

var assign = require('object-assign');

/**
 * The agent lives on the page in the same context as React, observes events
 * from the `backend`, and communicates (via a `Bridge`) with the frontend.
 *
 * It is responsible for generating string IDs (ElementID) for each react
 * element, maintaining a mapping of those IDs to elements, handling messages
 * from the frontend, and translating between react elements and native
 * handles.
 *
 *
 *   React
 *     |
 *     v
 *  backend
 *     |
 *     v
 *  -----------
 * | **Agent** |
 *  -----------
 *     ^
 *     |
 *     v
 *  (Bridge)
 *     ^
 *     |
 * serialization
 *     |
 *     v
 *  (Bridge)
 *     ^
 *     |
 *     v
 *  ----------------
 * | Frontend Store |
 *  ----------------
 *
 *
 * Events from the `backend`:
 * - root (got a root)
 * - mount (a component mounted)
 * - update (a component updated)
 * - unmount (a component mounted)
 *
 * Events from the `frontend` Store:
 * - see `addBridge` for subscriptions
 *
 * Events that Agent fires:
 * - selected
 * - hideHighlight
 * - startInspecting
 * - stopInspecting
 * - shutdown
 * - highlight /highlightMany
 * - setSelection
 * - root
 * - mount
 * - update
 * - unmount
 */

var Agent = (function (_EventEmitter) {
  function Agent(global, capabilities) {
    var _this = this;

    _classCallCheck(this, Agent);

    _get(Object.getPrototypeOf(Agent.prototype), 'constructor', this).call(this);
    this.global = global;
    this.reactElements = new Map();
    this.ids = new WeakMap();
    this.renderers = new Map();
    this.elementData = new Map();
    this.roots = new Set();
    this.reactInternals = {};
    this.on('selected', function (id) {
      var data = _this.elementData.get(id);
      if (data && data.publicInstance) {
        _this.global.$r = data.publicInstance;
      }
    });
    this._prevSelected = null;
    var isReactDOM = window.document && typeof window.document.createElement === 'function';
    this.capabilities = assign({
      scroll: isReactDOM && typeof window.document.body.scrollIntoView === 'function',
      dom: isReactDOM,
      editTextContent: false }, capabilities);
  }

  _inherits(Agent, _EventEmitter);

  _createClass(Agent, [{
    key: 'sub',

    // returns an "unsubscribe" function
    value: function sub(ev, fn) {
      var _this2 = this;

      this.on(ev, fn);
      return function () {
        _this2.removeListener(ev, fn);
      };
    }
  }, {
    key: 'setReactInternals',
    value: function setReactInternals(renderer, reactInternals) {
      this.reactInternals[renderer] = reactInternals;
    }
  }, {
    key: 'addBridge',
    value: function addBridge(bridge) {
      var _this3 = this;

      /** Events received from the frontend **/
      // the initial handshake
      bridge.on('requestCapabilities', function () {
        bridge.send('capabilities', _this3.capabilities);
        _this3.emit('connected');
      });
      bridge.on('setState', this._setState.bind(this));
      bridge.on('setProps', this._setProps.bind(this));
      bridge.on('setContext', this._setContext.bind(this));
      bridge.on('makeGlobal', this._makeGlobal.bind(this));
      bridge.on('highlight', function (id) {
        return _this3.highlight(id);
      });
      bridge.on('highlightMany', function (id) {
        return _this3.highlightMany(id);
      });
      bridge.on('hideHighlight', function () {
        return _this3.emit('hideHighlight');
      });
      bridge.on('startInspecting', function () {
        return _this3.emit('startInspecting');
      });
      bridge.on('stopInspecting', function () {
        return _this3.emit('stopInspecting');
      });
      bridge.on('selected', function (id) {
        return _this3.emit('selected', id);
      });
      bridge.on('shutdown', function () {
        return _this3.emit('shutdown');
      });
      bridge.on('changeTextContent', function (_ref) {
        var id = _ref.id;
        var text = _ref.text;

        var node = _this3.getNodeForID(id);
        if (!node) {
          return;
        }
        node.textContent = text;
      });
      // used to "inspect node in Elements pane"
      bridge.on('putSelectedNode', function (id) {
        window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$node = _this3.getNodeForID(id);
      });
      // used to "view source in Sources pane"
      bridge.on('putSelectedInstance', function (id) {
        var node = _this3.elementData.get(id);
        if (node.publicInstance) {
          window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$inst = node.publicInstance;
        } else {
          window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$inst = null;
        }
      });
      // used to select the inspected node ($0)
      bridge.on('checkSelection', function () {
        var newSelected = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0;
        if (newSelected !== _this3._prevSelected) {
          _this3._prevSelected = newSelected;
          var sentSelected = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$node;
          if (newSelected !== sentSelected) {
            _this3.selectFromDOMNode(newSelected, true);
          }
        }
      });
      bridge.on('scrollToNode', function (id) {
        return _this3.scrollToNode(id);
      });

      /** Events sent to the frontend **/
      this.on('root', function (id) {
        return bridge.send('root', id);
      });
      this.on('mount', function (data) {
        return bridge.send('mount', data);
      });
      this.on('update', function (data) {
        return bridge.send('update', data);
      });
      this.on('unmount', function (id) {
        bridge.send('unmount', id);
        // once an element has been unmounted, the bridge doesn't need to be
        // able to inspect it anymore.
        bridge.forget(id);
      });
      this.on('setSelection', function (data) {
        return bridge.send('select', data);
      });
    }
  }, {
    key: 'scrollToNode',
    value: function scrollToNode(id) {
      var node = this.getNodeForID(id);
      if (!node) {
        console.warn('unable to get the node for scrolling');
        return;
      }
      if (node.scrollIntoViewIfNeeded) {
        node.scrollIntoViewIfNeeded();
      } else {
        node.scrollIntoView();
      }
      this.highlight(id);
    }
  }, {
    key: 'highlight',
    value: function highlight(id) {
      var data = this.elementData.get(id);
      var node = this.getNodeForID(id);
      if (node) {
        this.emit('highlight', { node: node, name: data.name, props: data.props });
      }
    }
  }, {
    key: 'highlightMany',
    value: function highlightMany(ids) {
      var _this4 = this;

      var nodes = [];
      ids.forEach(function (id) {
        var node = _this4.getNodeForID(id);
        if (node) {
          nodes.push(node);
        }
      });
      if (nodes.length) {
        this.emit('highlightMany', nodes);
      }
    }
  }, {
    key: 'getNodeForID',
    value: function getNodeForID(id) {
      var component = this.reactElements.get(id);
      if (!component) {
        return null;
      }
      var renderer = this.renderers.get(id);
      if (this.reactInternals[renderer].getNativeFromReactElement) {
        return this.reactInternals[renderer].getNativeFromReactElement(component);
      }
    }
  }, {
    key: 'selectFromDOMNode',
    value: function selectFromDOMNode(node, quiet) {
      var id = this.getIDForNode(node);
      if (!id) {
        return;
      }
      this.emit('setSelection', { id: id, quiet: quiet });
    }
  }, {
    key: 'selectFromReactInstance',
    value: function selectFromReactInstance(instance, quiet) {
      var id = this.getId(instance);
      if (!id) {
        console.log('no instance id', instance);
        return;
      }
      this.emit('setSelection', { id: id, quiet: quiet });
    }
  }, {
    key: 'getIDForNode',
    value: function getIDForNode(node) {
      if (!this.reactInternals) {
        return null;
      }
      var component;
      for (var renderer in this.reactInternals) {
        // If a renderer doesn't know about a reactId, it will throw an error.
        try {
          // $FlowFixMe possibly null - it's not null
          component = this.reactInternals[renderer].getReactElementFromNative(node);
        } catch (e) {}
        if (component) {
          return this.getId(component);
        }
      }
    }
  }, {
    key: '_setProps',
    value: function _setProps(_ref2) {
      var id = _ref2.id;
      var path = _ref2.path;
      var value = _ref2.value;
      return (function () {
        var data = this.elementData.get(id);
        if (data.updater && data.updater.setInProps) {
          data.updater.setInProps(path, value);
        } else {
          console.warn('trying to set props on a component that doesn\'t support it');
        }
      }).apply(this, arguments);
    }
  }, {
    key: '_setState',
    value: function _setState(_ref3) {
      var id = _ref3.id;
      var path = _ref3.path;
      var value = _ref3.value;
      return (function () {
        var data = this.elementData.get(id);
        if (data.updater && data.updater.setInState) {
          data.updater.setInState(path, value);
        } else {
          console.warn('trying to set state on a component that doesn\'t support it');
        }
      }).apply(this, arguments);
    }
  }, {
    key: '_setContext',
    value: function _setContext(_ref4) {
      var id = _ref4.id;
      var path = _ref4.path;
      var value = _ref4.value;
      return (function () {
        var data = this.elementData.get(id);
        if (data.updater && data.updater.setInContext) {
          data.updater.setInContext(path, value);
        } else {
          console.warn('trying to set state on a component that doesn\'t support it');
        }
      }).apply(this, arguments);
    }
  }, {
    key: '_makeGlobal',
    value: function _makeGlobal(_ref5) {
      var id = _ref5.id;
      var path = _ref5.path;
      return (function () {
        var data = this.elementData.get(id);
        var value;
        if (path === 'instance') {
          value = data.publicInstance;
        } else {
          value = getIn(data, path);
        }
        this.global.$tmp = value;
        console.log('$tmp =', value);
      }).apply(this, arguments);
    }
  }, {
    key: 'getId',
    value: function getId(element) {
      if (typeof element !== 'object') {
        return element;
      }
      if (!this.ids.has(element)) {
        this.ids.set(element, randid());
        this.reactElements.set(this.ids.get(element), element);
      }
      return this.ids.get(element);
    }
  }, {
    key: 'addRoot',
    value: function addRoot(renderer, element) {
      var id = this.getId(element);
      this.roots.add(id);
      this.emit('root', id);
    }
  }, {
    key: 'onMounted',
    value: function onMounted(renderer, component, data) {
      var _this5 = this;

      var id = this.getId(component);
      this.renderers.set(id, renderer);
      this.elementData.set(id, data);

      var send = assign({}, data);
      if (send.children && send.children.map) {
        send.children = send.children.map(function (c) {
          return _this5.getId(c);
        });
      }
      send.id = id;
      send.canUpdate = send.updater && !!send.updater.forceUpdate;
      delete send.type;
      delete send.updater;
      this.emit('mount', send);
    }
  }, {
    key: 'onUpdated',
    value: function onUpdated(component, data) {
      var _this6 = this;

      var id = this.getId(component);
      this.elementData.set(id, data);

      var send = assign({}, data);
      if (send.children && send.children.map) {
        send.children = send.children.map(function (c) {
          return _this6.getId(c);
        });
      }
      send.id = id;
      send.canUpdate = send.updater && !!send.updater.forceUpdate;
      delete send.type;
      delete send.updater;
      this.emit('update', send);
    }
  }, {
    key: 'onUnmounted',
    value: function onUnmounted(component) {
      var id = this.getId(component);
      this.elementData['delete'](id);
      this.roots['delete'](id);
      this.renderers['delete'](id);
      this.emit('unmount', id);
      this.ids['delete'](component);
    }
  }]);

  return Agent;
})(EventEmitter);

function randid() {
  return Math.random().toString(16).slice(2);
}

function getIn(base, path) {
  return path.reduce(function (obj, attr) {
    return obj ? obj[attr] : null;
  }, base);
}

module.exports = Agent;

// the window or global -> used to "make a value available in the console"
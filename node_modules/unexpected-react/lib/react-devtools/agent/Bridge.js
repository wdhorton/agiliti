/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @flow
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var consts = require('./consts');
var hydrate = require('./hydrate');
var dehydrate = require('./dehydrate');

/**
 * The bridge is responsible for serializing requests between the Agent and
 * the Frontend Store. It needs to be connected to a Wall object that can send
 * JSONable data to the bridge on the other side.
 *
 * complex data
 *     |
 *     v
 *  [Bridge]
 *     |
 * jsonable data
 *     |
 *     v
 *   [wall]
 *     |
 *     v
 * ~ some barrier ~
 *     |
 *     v
 *   [wall]
 *     |
 *     v
 *  [Bridge]
 *     |
 *     v
 * "hydrated" data
 *
 * When an item is passed in that can't be serialized (anything other than a
 * plain array, object, or literal value), the object is "cleaned", and
 * rehydrated on the other side with `Symbol` attributes indicating that the
 * object needs to be inspected for more detail.
 *
 * Example:
 *
 * bridge.send('evname', {id: 'someid', foo: MyCoolObjectInstance})
 * ->
 * shows up, hydrated as
 * {
 *   id: 'someid',
 *   foo: {
 *     [consts.name]: 'MyCoolObjectInstance',
 *     [consts.type]: 'object',
 *     [consts.meta]: {},
 *     [consts.inspected]: false,
 *   }
 * }
 *
 * The `consts` variables are Symbols, and as such are non-ennumerable.
 * The front-end therefore needs to check for `consts.inspected` on received
 * objects, and can thereby display object proxies and inspect them.
 *
 * Complex objects that are passed are expected to have a top-level `id`
 * attribute, which is used for later lookup + inspection. Once it has been
 * determined that an object is no longer needed, call `.forget(id)` to clean
 * up.
 */

var Bridge = (function () {
  function Bridge(wall) {
    _classCallCheck(this, Bridge);

    this._cbs = new Map();
    this._inspectables = new Map();
    this._cid = 0;
    this._listeners = {};
    this._buffer = [];
    this._waiting = null;
    this._lastTime = 5;
    this._callers = {};
    this._paused = false;
    this._wall = wall;

    wall.listen(this._handleMessage.bind(this));
  }

  _createClass(Bridge, [{
    key: 'inspect',
    value: function inspect(id, path, cb) {
      var _cid = this._cid++;
      this._cbs.set(_cid, function (data, cleaned, proto, protoclean) {
        if (cleaned.length) {
          hydrate(data, cleaned);
        }
        if (proto && protoclean.length) {
          hydrate(proto, protoclean);
        }
        if (proto) {
          data[consts.proto] = proto;
        }
        cb(data);
      });

      this._wall.send({
        type: 'inspect',
        callback: _cid,
        path: path,
        id: id });
    }
  }, {
    key: 'call',
    value: function call(name, args, cb) {
      var _cid = this._cid++;
      this._cbs.set(_cid, cb);

      this._wall.send({
        type: 'call',
        callback: _cid,
        args: args,
        name: name });
    }
  }, {
    key: 'onCall',
    value: function onCall(name, handler) {
      if (this._callers[name]) {
        throw new Error('only one call handler per call name allowed');
      }
      this._callers[name] = handler;
    }
  }, {
    key: 'pause',
    value: function pause() {
      this._wall.send({
        type: 'pause' });
    }
  }, {
    key: 'resume',
    value: function resume() {
      this._wall.send({
        type: 'resume' });
    }
  }, {
    key: 'setInspectable',
    value: function setInspectable(id, data) {
      var prev = this._inspectables.get(id);
      if (!prev) {
        this._inspectables.set(id, data);
        return;
      }
      this._inspectables.set(id, _extends({}, prev, data));
    }
  }, {
    key: 'sendOne',
    value: function sendOne(evt, data) {
      var cleaned = [];
      var san = dehydrate(data, cleaned);
      if (cleaned.length) {
        this.setInspectable(data.id, data);
      }
      this._wall.send({ type: 'event', evt: evt, data: san, cleaned: cleaned });
    }
  }, {
    key: 'send',
    value: function send(evt, data) {
      var _this = this;

      if (!this._waiting && !this._paused) {
        this._buffer = [];
        var nextTime = this._lastTime * 3;
        if (nextTime > 500) {
          // flush is taking an unexpected amount of time
          nextTime = 500;
        }
        this._waiting = setTimeout(function () {
          _this.flush();
          _this._waiting = null;
        }, nextTime);
      }
      this._buffer.push({ evt: evt, data: data });
    }
  }, {
    key: 'flush',
    value: function flush() {
      var _this2 = this;

      var start = performance.now();
      var events = this._buffer.map(function (_ref) {
        var evt = _ref.evt;
        var data = _ref.data;

        var cleaned = [];
        var san = dehydrate(data, cleaned);
        if (cleaned.length) {
          _this2.setInspectable(data.id, data);
        }
        return { type: 'event', evt: evt, data: san, cleaned: cleaned };
      });
      this._wall.send({ type: 'many-events', events: events });
      this._buffer = [];
      this._waiting = null;
      this._lastTime = performance.now() - start;
    }
  }, {
    key: 'forget',
    value: function forget(id) {
      this._inspectables['delete'](id);
    }
  }, {
    key: 'on',
    value: function on(evt, fn) {
      if (!this._listeners[evt]) {
        this._listeners[evt] = [fn];
      } else {
        this._listeners[evt].push(fn);
      }
    }
  }, {
    key: 'off',
    value: function off(evt, fn) {
      if (!this._listeners[evt]) {
        return;
      }
      var ix = this._listeners[evt].indexOf(fn);
      if (ix !== -1) {
        this._listeners[evt].splice(ix, 1);
      }
    }
  }, {
    key: 'once',
    value: function once(evt, fn) {
      var self = this;
      var listener = function listener() {
        fn.apply(this, arguments);
        self.off(evt, listener);
      };
      this.on(evt, listener);
    }
  }, {
    key: '_handleMessage',
    value: function _handleMessage(payload) {
      var _this3 = this;

      if (payload.type === 'resume') {
        this._paused = false;
        this._waiting = null;
        this.flush();
        return;
      }

      if (payload.type === 'pause') {
        this._paused = true;
        clearTimeout(this._waiting);
        this._waiting = null;
        return;
      }

      if (payload.type === 'callback') {
        this._cbs.get(payload.id).apply(undefined, _toConsumableArray(payload.args));
        this._cbs['delete'](payload.id);
        return;
      }

      if (payload.type === 'call') {
        this._handleCall(payload.name, payload.args, payload.callback);
        return;
      }

      if (payload.type === 'inspect') {
        this._inspectResponse(payload.id, payload.path, payload.callback);
        return;
      }

      if (payload.type === 'event') {
        // console.log('[bridge<-]', payload.evt);
        if (payload.cleaned) {
          hydrate(payload.data, payload.cleaned);
        }
        var fns = this._listeners[payload.evt];
        var data = payload.data;
        if (fns) {
          fns.forEach(function (fn) {
            return fn(data);
          });
        }
      }

      if (payload.type === 'many-events') {
        payload.events.forEach(function (event) {
          // console.log('[bridge<-]', payload.evt);
          if (event.cleaned) {
            hydrate(event.data, event.cleaned);
          }
          var handlers = _this3._listeners[event.evt];
          if (handlers) {
            handlers.forEach(function (fn) {
              return fn(event.data);
            });
          }
        });
      }
    }
  }, {
    key: '_handleCall',
    value: function _handleCall(name, args, callback) {
      if (!this._callers[name]) {
        return console.warn('unknown call');
      }
      args = !Array.isArray(args) ? [args] : args;
      var result;
      try {
        result = this._callers[name].apply(null, args);
      } catch (e) {
        console.error('Failed to call', e);
        return undefined;
      }
      this._wall.send({
        type: 'callback',
        id: callback,
        args: [result] });
    }
  }, {
    key: '_inspectResponse',
    value: function _inspectResponse(id, path, callback) {
      var val = getIn(this._inspectables.get(id), path);
      var result = {};
      var cleaned = [];
      var proto = null;
      var protoclean = [];
      if (val) {
        var protod = false;
        var isFn = typeof val === 'function';
        Object.getOwnPropertyNames(val).forEach(function (name) {
          if (name === '__proto__') {
            protod = true;
          }
          if (isFn && (name === 'arguments' || name === 'callee' || name === 'caller')) {
            return;
          }
          result[name] = dehydrate(val[name], cleaned, [name]);
        });

        /* eslint-disable no-proto */
        if (!protod && val.__proto__ && val.constructor.name !== 'Object') {
          var newProto = {};
          var pIsFn = typeof val.__proto__ === 'function';
          Object.getOwnPropertyNames(val.__proto__).forEach(function (name) {
            if (pIsFn && (name === 'arguments' || name === 'callee' || name === 'caller')) {
              return;
            }
            newProto[name] = dehydrate(val.__proto__[name], protoclean, [name]);
          });
          proto = newProto;
        }
        /* eslint-enable no-proto */
      }

      this._wall.send({
        type: 'callback',
        id: callback,
        args: [result, cleaned, proto, protoclean] });
    }
  }]);

  return Bridge;
})();

function getIn(base, path) {
  return path.reduce(function (obj, attr) {
    return obj ? obj[attr] : null;
  }, base);
}

module.exports = Bridge;
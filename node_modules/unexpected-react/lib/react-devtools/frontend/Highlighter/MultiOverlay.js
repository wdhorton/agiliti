/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @flow
 */
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var assign = require('object-assign');

var MultiOverlay = (function () {
  function MultiOverlay(window) {
    _classCallCheck(this, MultiOverlay);

    this.win = window;
    var doc = window.document;
    this.container = doc.createElement('div');
    doc.body.appendChild(this.container);
  }

  _createClass(MultiOverlay, [{
    key: 'highlightMany',
    value: function highlightMany(nodes) {
      var _this = this;

      this.container.innerHTML = '';
      nodes.forEach(function (node) {
        var div = _this.win.document.createElement('div');
        var box = node.getBoundingClientRect();
        assign(div.style, {
          top: box.top + 'px',
          left: box.left + 'px',
          width: box.width + 'px',
          height: box.height + 'px',
          border: '2px dotted rgba(200, 100, 100, .8)',
          boxSizing: 'border-box',
          backgroundColor: 'rgba(200, 100, 100, .2)',
          position: 'fixed',
          zIndex: 10000000,
          pointerEvents: 'none' });
        _this.container.appendChild(div);
      });
    }
  }, {
    key: 'remove',
    value: function remove() {
      if (this.container.parentNode) {
        this.container.parentNode.removeChild(this.container);
      }
    }
  }]);

  return MultiOverlay;
})();

module.exports = MultiOverlay;
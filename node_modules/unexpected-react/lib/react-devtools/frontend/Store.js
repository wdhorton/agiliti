/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @flow
 */
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _require = require('events');

var EventEmitter = _require.EventEmitter;

var _require2 = require('immutable');

var Map = _require2.Map;
var Set = _require2.Set;
var List = _require2.List;

var assign = require('object-assign');
var nodeMatchesText = require('./nodeMatchesText');
var consts = require('../agent/consts');
var invariant = require('./invariant');

/**
 * This is the main frontend [fluxy?] Store, responsible for taking care of
 * state. It emits events when things change that you can subscribe to. The
 * best way to interact with the Store (if you are a React Component) is to
 * use the decorator in `decorate.js`. The top-level component (defined
 * by a shell) is generally responsible for creating the Store connecting it
 * up to a bridge, and putting it on `context` so the decorator can access it.
 *
 * Public events:
 *
 * - connected / connection failed
 * - roots
 * - searchText
 * - searchRoots
 * - contextMenu
 * - hover
 * - selected
 * - [node id]
 *
 * Public state:
 *  see attrs / constructor
 *
 * Public actions:
 * - scrollToNode(id)
 * - changeTextContent(id, text)
 * - changeSearch
 * - hoverClass
 * - selectFirstOfClass
 * - showContextMenu
 * - hideContextMenu
 * - selectFirstSearchResult
 * - toggleCollapse
 * - setProps/State/Context
 * - makeGlobal(id, path)
 * - setHover(id, isHovered)
 * - selectTop(id)
 * - selectBottom(id)
 * - select(id)
 *
 * Public methods:
 * - get(id) => Map (the node)
 * - getParent(id) => pid
 * - skipWrapper(id, up?) => id
 * - hasBottom(id) => bool
 * - on / off
 * - inspect(id, path, cb)
 */

var Store = (function (_EventEmitter) {
  function Store(bridge) {
    var _this = this;

    _classCallCheck(this, Store);

    _get(Object.getPrototypeOf(Store.prototype), 'constructor', this).call(this);
    this._nodes = new Map();
    this._parents = new Map();
    this._nodesByName = new Map();
    this._bridge = bridge;

    // Public state
    this.roots = new List();
    this.contextMenu = null;
    this.searchRoots = null;
    this.hovered = null;
    this.selected = null;
    this.selectedTab = 'Elements';
    this.breadcrumbHead = null;
    this.isBottomTagSelected = false;
    this.searchText = '';
    this.capabilities = {};

    // for debugging
    window.store = this;

    // events from the backend
    this._bridge.on('root', function (id) {
      if (_this.roots.contains(id)) {
        return;
      }
      _this.roots = _this.roots.push(id);
      if (!_this.selected) {
        _this.selected = _this.skipWrapper(id);
        _this.breadcrumbHead = _this.selected;
        _this.emit('selected');
        _this.emit('breadcrumbHead');
        _this._bridge.send('selected', _this.selected);
      }
      _this.emit('roots');
    });
    this._bridge.on('mount', function (data) {
      return _this._mountComponent(data);
    });
    this._bridge.on('update', function (data) {
      return _this._updateComponent(data);
    });
    this._bridge.on('unmount', function (id) {
      return _this._unmountComponenent(id);
    });
    this._bridge.on('select', function (_ref) {
      var id = _ref.id;
      var quiet = _ref.quiet;

      _this._revealDeep(id);
      _this.selectTop(_this.skipWrapper(id), quiet);
      _this.setSelectedTab('Elements');
    });

    this._establishConnection();
    this._eventQueue = [];
    this._eventTimer = null;
  }

  _inherits(Store, _EventEmitter);

  _createClass(Store, [{
    key: 'emit',
    value: function emit(event) {
      var _this2 = this;

      if (!this._eventTimer) {
        this._eventTimer = setTimeout(function () {
          _this2._eventQueue.forEach(function (evt) {
            EventEmitter.prototype.emit.call(_this2, evt);
          });
          _this2._eventQueue = [];
          _this2._eventTimer = null;
        }, 50);
        this._eventQueue = [];
      }
      if (this._eventQueue.indexOf(event) === -1) {
        this._eventQueue.push(event);
      }
      // to appease flow
      return true;
    }
  }, {
    key: 'scrollToNode',

    // Public actions
    value: function scrollToNode(id) {
      this._bridge.send('scrollToNode', id);
    }
  }, {
    key: 'setSelectedTab',
    value: function setSelectedTab(name) {
      if (this.selectedTab === name) {
        return;
      }
      this.selectedTab = name;
      this.emit('selectedTab');
    }
  }, {
    key: 'changeTextContent',

    // TODO(jared): get this working for react native
    value: function changeTextContent(id, text) {
      this._bridge.send('changeTextContent', { id: id, text: text });
      var node = this._nodes.get(id);
      if (node.get('nodeType') === 'Text') {
        this._nodes = this._nodes.set(id, node.set('text', text));
      } else {
        this._nodes = this._nodes.set(id, node.set('children', text));
        var props = node.get('props');
        props.children = text;
      }
      this.emit(id);
    }
  }, {
    key: 'changeSearch',
    value: function changeSearch(text) {
      var _this3 = this;

      var needle = text.toLowerCase();
      if (needle === this.searchText.toLowerCase()) {
        return;
      }
      if (!text) {
        this.searchRoots = null;
      } else {
        if (this.searchRoots && needle.indexOf(this.searchText.toLowerCase()) === 0) {
          this.searchRoots = this.searchRoots.filter(function (item) {
            var node = _this3.get(item);
            return node.get('name') && node.get('name').toLowerCase().indexOf(needle) !== -1 || node.get('text') && node.get('text').toLowerCase().indexOf(needle) !== -1 || typeof node.get('children') === 'string' && node.get('children').toLowerCase().indexOf(needle) !== -1;
          });
        } else {
          this.searchRoots = this._nodes.entrySeq().filter(function (_ref2) {
            var _ref22 = _slicedToArray(_ref2, 2);

            var key = _ref22[0];
            var val = _ref22[1];
            return nodeMatchesText(val, needle, key, _this3);
          }).map(function (_ref3) {
            var _ref32 = _slicedToArray(_ref3, 2);

            var key = _ref32[0];
            var val = _ref32[1];
            return key;
          }).toList();
        }
        // $FlowFixMe this.searchRoots is not falsey
        this.searchRoots.forEach(function (id) {
          if (_this3.hasBottom(id)) {
            _this3._nodes = _this3._nodes.setIn([id, 'collapsed'], true);
          }
        });
      }
      this.searchText = text;
      this.emit('searchText');
      this.emit('searchRoots');
      if (this.searchRoots && !this.searchRoots.contains(this.selected)) {
        this.select(null, true);
      } else if (!this.searchRoots) {
        if (this.selected) {
          this._revealDeep(this.selected);
        } else {
          this.select(this.roots.get(0));
        }
      }
    }
  }, {
    key: 'hoverClass',
    value: function hoverClass(name) {
      if (name === null) {
        this._bridge.send('hideHighlight');
        return;
      }
      var ids = this._nodesByName.get(name);
      if (!ids) {
        return;
      }
      this._bridge.send('highlightMany', ids.toArray());
    }
  }, {
    key: 'selectFirstOfClass',
    value: function selectFirstOfClass(name) {
      var ids = this._nodesByName.get(name);
      if (!ids || !ids.size) {
        return;
      }
      var id = ids.toSeq().first();
      this._revealDeep(id);
      this.selectTop(id);
    }
  }, {
    key: 'showContextMenu',
    value: function showContextMenu(type, evt) {
      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      evt.preventDefault();
      this.contextMenu = { type: type, x: evt.pageX, y: evt.pageY, args: args };
      this.emit('contextMenu');
    }
  }, {
    key: 'hideContextMenu',
    value: function hideContextMenu() {
      this.contextMenu = null;
      this.emit('contextMenu');
    }
  }, {
    key: 'selectFirstSearchResult',
    value: function selectFirstSearchResult() {
      if (this.searchRoots) {
        this.select(this.searchRoots.get(0), true);
      }
    }
  }, {
    key: 'hasBottom',
    value: function hasBottom(id) {
      var node = this.get(id);
      var children = node.get('children');
      if (node.get('nodeType') === 'NativeWrapper') {
        children = this.get(children[0]).get('children');
      }
      if (typeof children === 'string' || !children || !children.length || node.get('collapsed')) {
        return false;
      }
      return true;
    }
  }, {
    key: 'toggleCollapse',
    value: function toggleCollapse(id) {
      this._nodes = this._nodes.updateIn([id, 'collapsed'], function (c) {
        return !c;
      });
      this.emit(id);
    }
  }, {
    key: 'setProps',
    value: function setProps(id, path, value) {
      this._bridge.send('setProps', { id: id, path: path, value: value });
    }
  }, {
    key: 'setState',
    value: function setState(id, path, value) {
      this._bridge.send('setState', { id: id, path: path, value: value });
    }
  }, {
    key: 'setContext',
    value: function setContext(id, path, value) {
      this._bridge.send('setContext', { id: id, path: path, value: value });
    }
  }, {
    key: 'makeGlobal',
    value: function makeGlobal(id, path) {
      this._bridge.send('makeGlobal', { id: id, path: path });
    }
  }, {
    key: 'setHover',
    value: function setHover(id, isHovered) {
      if (isHovered) {
        var old = this.hovered;
        this.hovered = id;
        if (old) {
          this.emit(old);
        }
        this.emit(id);
        this.emit('hover');
        this._bridge.send('highlight', id);
      } else if (this.hovered === id) {
        this.hideHighlight();
      }
    }
  }, {
    key: 'hideHighlight',
    value: function hideHighlight() {
      this._bridge.send('hideHighlight');
      if (!this.hovered) {
        return;
      }
      var id = this.hovered;
      this.hovered = null;
      this.emit(id);
      this.emit('hover');
    }
  }, {
    key: 'selectBreadcrumb',
    value: function selectBreadcrumb(id) {
      this._revealDeep(id);
      this.changeSearch('');
      this.isBottomTagSelected = false;
      this.select(id, false, true);
    }
  }, {
    key: 'selectTop',
    value: function selectTop(id, noHighlight) {
      this.isBottomTagSelected = false;
      this.select(id, noHighlight);
    }
  }, {
    key: 'selectBottom',
    value: function selectBottom(id) {
      this.isBottomTagSelected = true;
      this.select(id);
    }
  }, {
    key: 'select',
    value: function select(id, noHighlight, keepBreadcrumb) {
      var oldSel = this.selected;
      this.selected = id;
      if (oldSel) {
        this.emit(oldSel);
      }
      if (id) {
        this.emit(id);
      }
      if (!keepBreadcrumb) {
        this.breadcrumbHead = id;
        this.emit('breadcrumbHead');
      }
      this.emit('selected');
      this._bridge.send('selected', id);
      if (!noHighlight) {
        this._bridge.send('highlight', id);
      }
    }
  }, {
    key: 'get',

    // Public methods
    value: function get(id) {
      return this._nodes.get(id);
    }
  }, {
    key: 'getParent',
    value: function getParent(id) {
      return this._parents.get(id);
    }
  }, {
    key: 'skipWrapper',
    value: function skipWrapper(id, up) {
      if (!id) {
        return undefined;
      }
      var node = this.get(id);
      var nodeType = node.get('nodeType');
      if (nodeType !== 'Wrapper' && nodeType !== 'Native') {
        return id;
      }
      if (nodeType === 'Native' && (!up || this.get(this._parents.get(id)).get('nodeType') !== 'NativeWrapper')) {
        return id;
      }
      if (up) {
        return this._parents.get(id);
      }
      return node.get('children')[0];
    }
  }, {
    key: 'off',
    value: function off(evt, fn) {
      this.removeListener(evt, fn);
    }
  }, {
    key: 'inspect',
    value: function inspect(id, path, cb) {
      var _this4 = this;

      invariant(path[0] === 'props' || path[0] === 'state' || path[0] === 'context', 'Inspected path must be one of props, state, or context');
      this._bridge.inspect(id, path, function (value) {
        var base = _this4.get(id).get(path[0]);
        var inspected = path.slice(1).reduce(function (obj, attr) {
          return obj ? obj[attr] : null;
        }, base);
        if (inspected) {
          assign(inspected, value);
          inspected[consts.inspected] = true;
        }
        cb();
      });
    }
  }, {
    key: '_establishConnection',

    // Private stuff
    value: function _establishConnection() {
      var _this5 = this;

      var tries = 0;
      var requestInt;
      this._bridge.once('capabilities', function (capabilities) {
        clearInterval(requestInt);
        _this5.capabilities = assign(_this5.capabilities, capabilities);
        _this5.emit('connected');
      });
      this._bridge.send('requestCapabilities');
      requestInt = setInterval(function () {
        tries += 1;
        if (tries > 100) {
          console.error('failed to connect');
          clearInterval(requestInt);
          _this5.emit('connection failed');
          return;
        }
        _this5._bridge.send('requestCapabilities');
      }, 500);
    }
  }, {
    key: '_revealDeep',
    value: function _revealDeep(id) {
      if (this.searchRoots && this.searchRoots.contains(id)) {
        return;
      }
      var pid = this._parents.get(id);
      while (pid) {
        if (this._nodes.getIn([pid, 'collapsed'])) {
          this._nodes = this._nodes.setIn([pid, 'collapsed'], false);
          this.emit(pid);
        }
        if (this.searchRoots && this.searchRoots.contains(pid)) {
          return;
        }
        pid = this._parents.get(pid);
      }
    }
  }, {
    key: '_mountComponent',
    value: function _mountComponent(data) {
      var _this6 = this;

      var map = Map(data).set('renders', 1);
      if (data.nodeType === 'Composite') {
        map = map.set('collapsed', true);
      }
      this._nodes = this._nodes.set(data.id, map);
      if (data.children && data.children.forEach) {
        data.children.forEach(function (cid) {
          _this6._parents = _this6._parents.set(cid, data.id);
        });
      }
      var curNodes = this._nodesByName.get(data.name) || new Set();
      this._nodesByName = this._nodesByName.set(data.name, curNodes.add(data.id));
      this.emit(data.id);
      if (this.searchRoots && nodeMatchesText(map, this.searchText.toLowerCase(), data.id, this)) {
        this.searchRoots = this.searchRoots.push(data.id);
        this.emit('searchRoots');
      }
    }
  }, {
    key: '_updateComponent',
    value: function _updateComponent(data) {
      var _this7 = this;

      var node = this.get(data.id);
      if (!node) {
        return;
      }
      data.renders = node.get('renders') + 1;
      this._nodes = this._nodes.mergeIn([data.id], Map(data));
      if (data.children && data.children.forEach) {
        data.children.forEach(function (cid) {
          _this7._parents = _this7._parents.set(cid, data.id);
        });
      }
      this.emit(data.id);
    }
  }, {
    key: '_unmountComponenent',
    value: function _unmountComponenent(id) {
      var pid = this._parents.get(id);
      this._removeFromNodesByName(id);
      this._parents = this._parents['delete'](id);
      this._nodes = this._nodes['delete'](id);
      if (pid) {
        this.emit(pid);
      } else {
        var ix = this.roots.indexOf(id);
        if (ix !== -1) {
          this.roots = this.roots['delete'](ix);
          this.emit('roots');
        }
      }
      if (id === this.selected) {
        var newsel = pid ? this.skipWrapper(pid, true) : this.roots.get(0);
        this.selectTop(newsel, true);
      }
      if (this.searchRoots && this.searchRoots.contains(id)) {
        // $FlowFixMe flow things searchRoots might be null
        this.searchRoots = this.searchRoots['delete'](this.searchRoots.indexOf(id));
        this.emit('searchRoots');
      }
    }
  }, {
    key: '_removeFromNodesByName',
    value: function _removeFromNodesByName(id) {
      var node = this._nodes.get(id);
      if (node) {
        this._nodesByName = this._nodesByName.set(node.get('name'), this._nodesByName.get(node.get('name'))['delete'](id));
      }
    }
  }]);

  return Store;
})(EventEmitter);

module.exports = Store;

// Public state

// an object describing the capabilities of the inspected runtime.
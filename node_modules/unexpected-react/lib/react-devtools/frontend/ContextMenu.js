/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @flow
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var React = require('react');
var HighlightHover = require('./HighlightHover');

var assign = require('object-assign');
var decorate = require('./decorate');

var ContextMenu = (function (_React$Component) {
  function ContextMenu() {
    _classCallCheck(this, ContextMenu);

    if (_React$Component != null) {
      _React$Component.apply(this, arguments);
    }
  }

  _inherits(ContextMenu, _React$Component);

  _createClass(ContextMenu, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      this._clickout = this.onMouseDown.bind(this);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.open && !prevProps.open) {
        window.addEventListener('mousedown', this._clickout, true);
      } else if (prevProps.open && !this.props.open) {
        window.removeEventListener('mousedown', this._clickout, true);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.removeEventListener('mousedown', this._clickout, true);
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(evt) {
      var n = evt.target;
      var container = React.findDOMNode(this);
      while (n) {
        if (n === container) {
          return;
        }
        n = n.offsetParent;
      }

      evt.preventDefault();
      this.props.hideContextMenu();
    }
  }, {
    key: 'onClick',
    value: function onClick(i, evt) {
      evt.preventDefault();
      this.props.items[i].action();
      this.props.hideContextMenu();
    }
  }, {
    key: 'render',
    value: function render() {
      var _this = this;

      if (!this.props.open) {
        return React.createElement('div', { style: styles.hidden });
      }

      var containerStyle = assign({}, styles.container, {
        top: this.props.pos.y + 'px',
        left: this.props.pos.x + 'px' });

      return React.createElement(
        'ul',
        { style: containerStyle },
        !this.props.items.length && React.createElement(
          'li',
          { style: styles.empty },
          'No actions'
        ),
        this.props.items.map(function (item, i) {
          return item && React.createElement(
            'li',
            { onClick: function (evt) {
                return _this.onClick(i, evt);
              } },
            React.createElement(
              HighlightHover,
              { style: styles.item },
              item.title
            )
          );
        })
      );
    }
  }]);

  return ContextMenu;
})(React.Component);

var Wrapped = decorate({
  listeners: function listeners() {
    return ['contextMenu'];
  },
  props: function props(store, _props) {
    if (!store.contextMenu) {
      return { open: false };
    }
    var _store$contextMenu = store.contextMenu;
    var x = _store$contextMenu.x;
    var y = _store$contextMenu.y;
    var type = _store$contextMenu.type;
    var args = _store$contextMenu.args;

    var items = [];
    args.push(store);

    _props.itemSources.forEach(function (source) {
      if (!source || !source[type]) {
        return;
      }
      var newItems = source[type].apply(source, _toConsumableArray(args));
      if (newItems) {
        items = items.concat(newItems.filter(function (v) {
          return !!v;
        }));
      }
    });

    return {
      open: true,
      pos: { x: x, y: y },
      hideContextMenu: function hideContextMenu() {
        return store.hideContextMenu();
      },
      items: items };
  } }, ContextMenu);

var styles = {
  hidden: {
    display: 'none' },

  container: {
    position: 'fixed',
    backgroundColor: 'white',
    boxShadow: '0 3px 5px #ccc',
    listStyle: 'none',
    margin: 0,
    padding: 0,
    fontFamily: 'sans-serif',
    fontSize: 14 },

  item: {
    padding: '5px 10px',
    cursor: 'pointer' },

  empty: {
    padding: '5px 10px',
    color: '#888' } };

module.exports = Wrapped;
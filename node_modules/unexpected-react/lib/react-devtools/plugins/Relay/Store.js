/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @flow
 */
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _require = require('events');

var EventEmitter = _require.EventEmitter;

var _require2 = require('immutable');

var OrderedMap = _require2.OrderedMap;
var Map = _require2.Map;

var assign = require('object-assign');
var consts = require('../../agent/consts');
var invariant = require('../../frontend/invariant');

function getDataIDs(obj, collector) {
  for (var name in obj) {
    if (name === 'id' && typeof obj[name] === 'string') {
      collector.push(obj[name]);
    } else if (typeof obj[name] === 'object') {
      getDataIDs(obj[name], collector);
    }
  }
}

var Store = (function (_EventEmitter) {
  function Store(bridge, mainStore) {
    var _this = this;

    _classCallCheck(this, Store);

    _get(Object.getPrototypeOf(Store.prototype), 'constructor', this).call(this);
    this.storeData = null;
    this.selectedQuery = null;
    this.queries = new OrderedMap();
    this._bridge = bridge;
    this._mainStore = mainStore;
    // initial population of the store
    bridge.on('relay:store', function (data) {
      _this.storeData = data;
      _this.emit('storeData');
    });
    this.queriesByDataID = {};
    // queries and mutations
    bridge.on('relay:pending', function (data) {
      _this.queries = _this.queries.set(data.id, new Map(data).set('status', 'pending'));
      _this.emit('queries');
      _this.emit(data.id);
      var dataIDs = [];
      getDataIDs(data.variables, dataIDs);
      dataIDs.forEach(function (id) {
        if (!_this.queriesByDataID[id]) {
          _this.queriesByDataID[id] = [data.id];
        } else {
          _this.queriesByDataID[id].push(data.id);
        }
      });
    });
    bridge.on('relay:success', function (_ref) {
      var id = _ref.id;
      var response = _ref.response;
      var end = _ref.end;

      _this.queries = _this.queries.mergeIn([id], new Map({ status: 'success', response: response, end: end }));
      _this.emit('queries');
      _this.emit(id);
    });
    bridge.on('relay:failure', function (_ref2) {
      var id = _ref2.id;
      var error = _ref2.error;
      var end = _ref2.end;

      _this.queries = _this.queries.mergeIn([id], new Map({ status: 'failure', error: error, end: end }));
      _this.emit('queries');
      _this.emit(id);
    });
    this.dataIDsToNodes = {};
    this.nodesToDataIDs = {};
    // track nodes
    bridge.on('mount', function (data) {
      if (!data.props || !data.props.relay && data.name.indexOf('Relay(') !== 0) {
        return; // not a relay child
      }
      _this.nodesToDataIDs[data.id] = new window.Set();
      for (var name in data.props) {
        var id = data.props[name].__dataID__;
        if (!id) {
          continue;
        }
        if (!_this.dataIDsToNodes[id]) {
          _this.dataIDsToNodes[id] = new window.Set();
        }
        _this.dataIDsToNodes[id].add(data.id);
        _this.nodesToDataIDs[data.id].add(id);
      }
    });
    bridge.on('update', function (data) {
      if (!data.props || !_this.nodesToDataIDs[data.id]) {
        return;
      }
      var newIds = new window.Set();
      for (var name in data.props) {
        var id = data.props[name].__dataID__;
        if (!id) {
          continue;
        }
        newIds.add(id);
        if (_this.nodesToDataIDs[data.id].has(id)) {
          continue;
        }
        if (!_this.dataIDsToNodes[id]) {
          _this.dataIDsToNodes[id] = new window.Set();
        }
        _this.dataIDsToNodes[id].add(data.id);
        // this.nodesToDataIDs[data.id].add(id);
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _this.nodesToDataIDs[data.id][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var item = _step.value;

          if (!newIds.has(item)) {
            _this.dataIDsToNodes[item]['delete'](data.id);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      _this.nodesToDataIDs[id] = newIds;
    });
    bridge.on('unmount', function (id) {
      if (!_this.nodesToDataIDs[id]) {
        return;
      }
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = _this.nodesToDataIDs[id][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var item = _step2.value;

          _this.dataIDsToNodes[item]['delete'](id);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2['return']) {
            _iterator2['return']();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      _this.nodesToDataIDs[id] = null;
    });
  }

  _inherits(Store, _EventEmitter);

  _createClass(Store, [{
    key: 'jumpToDataID',
    value: function jumpToDataID(dataID) {
      this._mainStore.setSelectedTab('RelayStore');
      this.selectedDataNode = dataID;
      this.emit('selectedDataNode');
    }
  }, {
    key: 'jumpToQuery',
    value: function jumpToQuery(queryID) {
      this._mainStore.setSelectedTab('Relay');
      this.selectedQuery = queryID;
      this.emit('selectedQuery');
      this.emit('queries');
    }
  }, {
    key: 'inspect',
    value: function inspect(id, path, cb) {
      var _this2 = this;

      this._bridge.inspect(id, path, function (value) {
        var base;
        if (id === 'relay:store') {
          invariant(_this2.storeData, 'RelayStore.inspect: this.storeData should be defined.');
          base = _this2.storeData.nodes;
        } else {
          base = _this2.queries.get(id).get(path[0]);
        }
        var inspected = path.slice(1).reduce(function (obj, attr) {
          return obj ? obj[attr] : null;
        }, base);
        if (inspected) {
          assign(inspected, value);
          inspected[consts.inspected] = true;
        }
        cb();
      });
    }
  }, {
    key: 'off',
    value: function off(evt, fn) {
      this.removeListener(evt, fn);
    }
  }, {
    key: 'selectQuery',
    value: function selectQuery(id) {
      this.selectedQuery = id;
      this.emit('selectedQuery');
    }
  }]);

  return Store;
})(EventEmitter);

module.exports = Store;
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */
'use strict';

require('es6-map/implement');
require('es6-set/implement');

var test = require('tape-catch');
var makeReporter = require('./reporter');
var spy = require('./spy');

var attachRenderer = require('../attachRenderer');
var globalHook = require('../GlobalHook.js');
globalHook(window);

if (!window.IS_TRAVIS) {
  makeReporter(test.createStream({ objectMode: true }));
}

var React = require('./v0.11/node_modules/react');

var _require = require('events');

var EventEmitter = _require.EventEmitter;

var renderer = React.__internals;

function tracker(hook) {
  var els = new Map();
  var roots = new Set();
  hook.on('root', function (_ref) {
    var element = _ref.element;
    return roots.add(element);
  });
  hook.on('unmount', function (_ref2) {
    var element = _ref2.element;

    roots['delete'](element);
    els['delete'](element);
  });
  hook.on('mount', function (_ref3) {
    var element = _ref3.element;
    var data = _ref3.data;

    els.set(element, [data]);
  });
  hook.on('update', function (_ref4) {
    var element = _ref4.element;
    var data = _ref4.data;

    els.get(element).push(data);
  });
  return { els: els, roots: roots };
}

function setup(hook) {
  var handlers = {
    root: spy(),
    mount: spy(),
    update: spy(),
    unmount: spy() };
  for (var name in handlers) {
    hook.on(name, handlers[name]);
  }
  return handlers;
}

function wrapElement(hook, element) {
  var extras = attachRenderer(hook, 'abc', renderer);
  var node = document.createElement('div');
  React.renderComponent(element, node);
  setTimeout(function () {
    extras.cleanup();
    React.unmountComponentAtNode(node);
  }, 0);
}

function wrapRender(hook, fn) {
  var extras = attachRenderer(hook, 'abc', renderer);
  fn();
  setTimeout(function () {
    extras.cleanup();
  }, 0);
}

var SimpleApp = React.createClass({
  displayName: 'SimpleApp',

  render: function render() {
    return React.DOM.div(null, 'Hello');
  } });

// Mounting and Unmounting

test('should work with plain DOM node', function (t) {
  var hook = new EventEmitter();
  var handlers = setup(hook);

  wrapElement(hook, React.DOM.div(null, 'Plain'));

  setTimeout(function () {
    t.ok(handlers.root.calledOnce, 'One root');
    // the div
    t.equal(handlers.mount.callCount, 1, 'One mount');
    t.notOk(handlers.unmount.called, 'No unmounts');
    t.end();
  }, 0);
});

test('should work with simple composite component', function (t) {
  var hook = new EventEmitter();
  var handlers = setup(hook);

  wrapElement(hook, React.createElement(SimpleApp, null));

  setTimeout(function () {
    t.ok(handlers.root.calledOnce, 'One root');
    // the composite component, and the div
    t.equal(handlers.mount.callCount, 2, 'Two mounts');
    t.notOk(handlers.unmount.called, 'No unmounts');
    t.end();
  }, 0);
});

test('attaching late should work', function (t) {
  var hook = new EventEmitter();
  var handlers = setup(hook);

  var node = document.createElement('div');
  React.renderComponent(React.createElement(SimpleApp, null), node);

  var extras = attachRenderer(hook, 'abc', renderer);
  extras.walkTree(function (component, data) {
    return handlers.mount({ component: component, data: data });
  }, function (component) {
    return handlers.root({ component: component });
  });

  t.equal(handlers.root.callCount, 1, 'One root');
  // the composite component, and the div
  t.equal(handlers.mount.callCount, 2, 'Two mounts');
  t.notOk(handlers.unmount.called, 'No unmounts');

  // cleanup after
  extras.cleanup();
  React.unmountComponentAtNode(node);

  t.end();
});

test('should unmount everything', function (t) {
  var hook = new EventEmitter();
  var els = new Set();
  hook.on('mount', function (_ref5) {
    var element = _ref5.element;
    return els.add(element);
  });
  hook.on('unmount', function (_ref6) {
    var element = _ref6.element;
    return els['delete'](element);
  });

  var node = document.createElement('div');
  wrapRender(hook, function () {
    React.renderComponent(React.createElement(SimpleApp, null), node);
    setTimeout(function () {
      t.ok(els.size > 0, 'Some elements');
      React.unmountComponentAtNode(node);
    }, 0);
  });

  setTimeout(function () {
    t.equal(els.size, 0, 'Everything unmounted');
    t.end();
  }, 0);
});

test('should register two roots', function (t) {
  var hook = new EventEmitter();
  var handlers = setup(hook);

  wrapRender(hook, function () {
    var node = document.createElement('div');
    var node2 = document.createElement('div');
    React.renderComponent(React.createElement(SimpleApp, null), node);
    React.renderComponent(React.createElement(SimpleApp, null), node2);
    React.unmountComponentAtNode(node);
    React.unmountComponentAtNode(node2);
  });

  t.equal(handlers.root.callCount, 2, 'Two roots');
  t.end();
});

test('Double render', function (t) {
  var hook = new EventEmitter();
  var handlers = setup(hook);
  var els = new Set();
  hook.on('mount', function (_ref7) {
    var element = _ref7.element;
    return els.add(element);
  });
  hook.on('unmount', function (_ref8) {
    var element = _ref8.element;
    return els['delete'](element);
  });

  wrapNode(function (node) {
    wrapRender(hook, function () {
      React.renderComponent(React.createElement(SimpleApp, null), node);
      t.equal(handlers.update.callCount, 0, 'No updates');
      React.renderComponent(React.createElement(SimpleApp, null), node);
    });
  });

  setTimeout(function () {
    t.equal(handlers.root.callCount, 1, 'One root');
    t.ok(handlers.update.callCount > 0, 'Updates');
    t.equal(els.size, 2, 'Only two mounted');
    t.end();
  }, 0);
});

test('Plain text nodes', function (t) {
  var hook = new EventEmitter();

  var _tracker = tracker(hook);

  var roots = _tracker.roots;
  var els = _tracker.els;

  var PlainApp = React.createClass({
    displayName: 'PlainApp',

    render: function render() {
      return React.DOM.div(null, 'one', ['two'], 'three');
    } });
  wrapElement(hook, React.createElement(PlainApp, null));

  setTimeout(function () {
    var composite = roots.values().next().value;
    var div = els.get(composite)[0].children[0];
    var texts = els.get(div)[0].children;

    var contents = ['one', 'two', 'three'];

    t.equals(texts.length, 3, '3 text children');

    texts.forEach(function (comp, i) {
      t.equals(els.get(comp)[0].text, contents[i], i + ') Text content correct');
      t.equals(els.get(comp)[0].nodeType, 'Text', i + ') NodeType = text');
    });

    t.end();
  }, 0);
});

// State updating

var StateApp = React.createClass({
  displayName: 'StateApp',

  getInitialState: function getInitialState() {
    return { updated: false };
  },
  render: function render() {
    return React.DOM.div(null, this.state.updated ? 'Updated' : 'Not updated');
  } });

function wrapNode(fn) {
  var node = document.createElement('div');
  fn(node);
  setTimeout(function () {
    React.unmountComponentAtNode(node);
  }, 0);
}

test('State update', function (t) {
  var hook = new EventEmitter();

  var _tracker2 = tracker(hook);

  var roots = _tracker2.roots;
  var els = _tracker2.els;

  wrapNode(function (node) {
    wrapRender(hook, function () {
      var App = React.renderComponent(React.createElement(StateApp, null), node);
      App.setState({ updated: true });
    });
  });

  setTimeout(function () {
    var composite = roots.values().next().value;
    var div = els.get(composite)[0].children[0];

    var divUpdates = els.get(div);
    t.equal(divUpdates[0].nodeType, 'Native', '[Div] Native type');
    t.equal(divUpdates[0].name, 'div', 'Named "div"');
    t.equal(divUpdates[1].children, 'Updated', 'Then, updated');
    var updates = els.get(composite);
    t.equal(updates[0].nodeType, 'Composite', '[App] Composite type');
    t.equal(updates[0].name, 'StateApp', 'Named "StateApp"');
    t.equal(updates[1].state.updated, true, 'State[1] updated=true');
    t.end();
  }, 0);
});

test('Props update', function (t) {
  var hook = new EventEmitter();

  var _tracker3 = tracker(hook);

  var roots = _tracker3.roots;
  var els = _tracker3.els;

  var StateProps = React.createClass({
    displayName: 'StateProps',

    getInitialState: function getInitialState() {
      return { pass: false };
    },
    render: function render() {
      return React.createElement(SimpleApp, { pass: this.state.pass });
    } });

  wrapNode(function (node) {
    wrapRender(hook, function () {
      var App = React.renderComponent(React.createElement(StateProps, null), node);
      App.setState({ pass: 100 });
    });
  });

  setTimeout(function () {
    var composite = roots.values().next().value;
    var simple = els.get(composite)[0].children[0];

    var updates = els.get(simple);
    // because of timing issues, the first mount will show the setState :(
    t.equal(updates[1].props.pass, 100, 't=1, prop=100');
    t.end();
  }, 0);
});